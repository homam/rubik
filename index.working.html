<!DOCTYPE html >

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript" src="Three.js"></script>
	<script src="_.js"></script>
	<script src="EventTarget.js"></script>
</head>
<body>
    <script>

        requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
		var tickerEvent = new EventTarget();
		var onTicks = [];

		var cubeSize = 100;
        var camera, scene, renderer, cubes = [], sphere;

        init();
        animate(new Date().getTime());

        function init() {

            // renderer
			renderer = (function() {
	            var renderer = new THREE.WebGLRenderer();
	            renderer.setSize(window.innerWidth, window.innerHeight);
	            document.body.appendChild(renderer.domElement);
	            renderer.setClearColorHex(0xEEEEEE, 1.0);
	            renderer.clear();
	            renderer.shadowCameraFov = 50;
	            renderer.shadowMapWidth = 1024;;
	            renderer.shadowMapHeight = 1024;
				return renderer;
			})();
            // scene
            scene = new THREE.Scene();

            // camera
            camera = (function () {
                var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.z = -500;
                camera.position.y = 620;
				camera.position.x = 400;
                return camera;
            })();
            scene.add(camera);

			[-1, 0, 1].forEach(function(x){
				[-1, 0, 1].forEach(function(y){
					[-1, 0, 1].forEach(function(z){
						var colors = [0xff0000, 0xffff00, 0x0000ff, 0x00ffff, 0x00ff00, 0xff00ff]
						var materials = [];
						for ( var i = 0; i < 6; i ++ ) {
							materials.push( new THREE.MeshBasicMaterial( { color: colors[i]} ) );
						}
						
						var cube = new THREE.Mesh(new THREE.CubeGeometry(cubeSize*.6, cubeSize*.6, cubeSize*.6, 1, 1, 1, materials),
							new THREE.MeshFaceMaterial());
						cube.position.set(x*cubeSize, y*cubeSize, z*cubeSize);
			            cube.castShadow = true;
			            cube.receiveShadow = true;
						cube.dynamic = true;
						cube.lookAt(new THREE.Vector3(cube.position.x , cube.position.y, cube.position.z))
						cube.rubik = {
							original: {x:x, y:y, z:z},
							current: {x:x, y:y, z:z},
							rotateZ: function(dir){
								var originalTime = null;
								var rotationPerTick = (Math.PI/2)/1000;
								var originalRotation = 0;
								var originalPosition;
								var anim = function(ev) {
									var time = ev.t;
									if(!originalTime) { // first call to anim()
										originalTime = time;
										originalRotation = cube.rotation.z;
										originalPosition = cube.position;
									}
									var t = (time-originalTime)*rotationPerTick; // current rotation (for the current tick)
									var end = false;
									if(t>= Math.PI/2) {
										t= Math.PI/2;
										end = true;
									}
									t*=dir; // adjust by direction
									var original = cube.rubik.current;
									
									var cos = Math.cos, sin = Math.sin;
									var matrix = new THREE.Matrix4(cos(t), sin(t),0,0,	 -sin(t), cos(t), 0,0, 	0,0,1,0,	0,0,0,1);
									var pos = matrix.multiplyVector3(new THREE.Vector3(original.x, original.y, original.z));
									
									var x = original.x * Math.cos(t) - original.y * Math.sin(t);
									var y = original.x * Math.sin(t) + original.y * Math.cos(t);
									var z = original.z;
									cube.position = pos.multiplyScalar(cubeSize);//.set(x*cubeSize,y*cubeSize,z*cubeSize);
									cube.rotation.z = originalRotation - t;
									
									if(end){
										cube.current = {x:-1*dir*y,y:dir*x,z:z};
										//onTicks[callBackId] = null;
										tickerEvent.removeListener("tick", anim);
									}
								}
								//callBackId = onTicks.push(anim)-1;
								tickerEvent.addListener("tick", anim);
							}
						};
			            scene.add(cube);
						cubes.push(cube);
					});
				});
			});



			// lights
            [
				new THREE.Vector3(3000,3000,3000),
 				new THREE.Vector3(-3000,-3000,-3000), 
				new THREE.Vector3(-3000,3000,-3000),
				new THREE.Vector3(3000,-3000,3000), 
				new THREE.Vector3(3000,-3000,-3000)].forEach(function(pos){
	
	            // light
	            var light = (function () {
	                var light = new THREE.SpotLight(0xFFFFFF);
	                light.castShadow = true;
	                light.position = pos;
	                light.dynamic = true;
	                scene.add(light);

	                var lightObj = new THREE.Mesh(new THREE.SphereGeometry(20, 20, 20),
						new THREE.MeshBasicMaterial({ color: 0xFCFC00 }));
	                lightObj.position = light.position;
	                lightObj.castShadow = false;
	                lightObj.receiveShadow = false;
	                scene.add(lightObj);

	                return light;
	            })();

				// point light
	            scene.add((function () {
	                var alight = new THREE.PointLight(0xFFFFFF, 5, 10000);
	                alight.position = light.position;
	                return alight;
	            })());


			});

			scene.add((function(){
				var ambientLight = new THREE.AmbientLight( 0xff3333 );
				return ambientLight;
			})());

			// axes
			(function(){
				function v(x,y,z){ 
			        return new THREE.Vertex(new THREE.Vector3(x,y,z)); 
				}

				var length = 5000;
				var axesGeos = [[v(0, 0, 0), v(length, 0, 0)], 
					[v(0, 0, 0), v(0, length, 0)],[v(0, 0, 0), v(0, 0, length)]];
					
				axesGeos.forEach(function(axe, index){
					var lineGeo = new THREE.Geometry();
					lineGeo.vertices = axe;
					var lineMat = new THREE.LineBasicMaterial({color:
						 index ==0 ? 0xff0000 : index == 1 ? 0x0000ff : 0x00ff00, lineWidth: 1});
					var line = new THREE.Line(lineGeo, lineMat);
					line.type = THREE.Lines;
					scene.add(line);
				});


			})() ;

            // sphere

            sphere = new THREE.Mesh(new THREE.SphereGeometry(50, 20, 20) ,  new THREE.MeshLambertMaterial({color: 0xCC0000}));
            sphere.position.set(50, 250, 550);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
           // scene.add(sphere);


            renderer.shadowMapEnabled = false;


        }

		function animate(t) {
            requestAnimationFrame(animate);
            render(t);
			for(var i = 0, length = onTicks.length; i<length; i++) {
				var f = onTicks[i];
				if(f)
					requestAnimationFrame(f);
			}
        }

        function render(t) {
          var cameraSpeed = 3000;

	  		//camera.position.x = Math.sin(t / cameraSpeed) * 1100 ;
            //camera.position.y = Math.sin(t/ cameraSpeed)*1100;
            //camera.position.z = Math.cos(t / cameraSpeed) * 1100;
            camera.lookAt(scene.position);

			sphere.position.x = Math.sin(t/1000) * 250;
			sphere.position.z = Math.cos(t/1000) * 250;
			
            //cube.rotation.z +=  0.01;
            //cube.rotation.y += 0.02;


            renderer.render(scene, camera);

			tickerEvent.fire({type:"tick", t:t});

        }



</script>

</body>
</html>
